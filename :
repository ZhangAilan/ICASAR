[1mdiff --git a/icasar/aux2.py b/icasar/aux2.py[m
[1mindex 9c084ea..b9c2687 100755[m
[1m--- a/icasar/aux2.py[m
[1m+++ b/icasar/aux2.py[m
[36m@@ -243,13 +243,18 @@[m [mdef update_mask_sources_ifgs(mask_sources, sources, mask_ifgs, ifgs):[m
             ifgs_new_mask | r2 array | as per ifgs, but with a new mask.  [m
         History:[m
             2020/06/26 | MEG | Written[m
[32m+[m[32m            2022_03_30 | MEG |  fix a bug in the number of pixels for the output array (ie. number of columns of ifgs_new_mask)[m
         """[m
[31m-        n_pixs_new = len(np.argwhere(mask_new == False))                                        [m
[31m-        ifgs_new_mask = np.zeros((ifgs.shape[0], n_pixs_new))                        # initiate an array to store the modified sources as row vectors    [m
[31m-        for ifg_n, ifg in enumerate(ifgs):                                 # Loop through each source[m
[31m-            ifg_r2 = col_to_ma(ifg, mask_old)                             # turn it from a row vector into a rank 2 masked array        [m
[31m-            ifg_r2_new_mask = ma.array(ifg_r2, mask = mask_new)              # apply the new mask   [m
[31m-            ifgs_new_mask[ifg_n, :] = ma.compressed(ifg_r2_new_mask)       # convert to row vector and places in rank 2 array of modified sources[m
[32m+[m
[32m+[m[41m        [m
[32m+[m[32m        for ifg_n, ifg in enumerate(ifgs):                                            # Loop through each source[m
[32m+[m[32m            ifg_r2 = col_to_ma(ifg, mask_old)                                         # turn it from a row vector into a rank 2 masked array[m[41m        [m
[32m+[m[32m            ifg_r2_new_mask = ma.array(ifg_r2, mask = mask_new)                       # apply the new mask[m[41m   [m
[32m+[m[32m            ifg_r1_new_mask = ma.compressed(ifg_r2_new_mask)                          # convert to row vector[m[41m [m
[32m+[m[32m            if ifg_n == 0:                                                            # if it's the first ifg..[m[41m  [m
[32m+[m[32m                n_pixs_new = ifg_r1_new_mask.shape[0]                                 # get the new number of pixels[m[41m [m
[32m+[m[32m                ifgs_new_mask = np.zeros((ifgs.shape[0], n_pixs_new))                 # initiate an array of the correct size[m
[32m+[m[32m            ifgs_new_mask[ifg_n, :] = ifg_r1_new_mask                                 # put the row vector into the array[m
         return ifgs_new_mask[m
     [m
     [m
